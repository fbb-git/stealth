lsect(COMMANDS)(Commands)

    Following the bf(USE) specifications, em(commands) can be specified. The
commands are executed in their order of appearance in the policy
file. Processing continues until the last command has been processed or until
a tested command (see below) returns a non-zero return value.

subsect(LABEL commands)
    
    The following bf(LABEL) commands are available:
    itemization(
    it() bf(LABEL) tt(text)

        This defines a text-label which is written to the bf(REPORT) file,
just before the output generated by the next bf(CHECK)-command. If the next
bf(CHECK)-command generates no output, the label is not written to the
bf(REPORT)-file. Once a bf(LABEL) has been defined, it is used until it is
redefined by the next bf(LABEL) command. Use an empty bf(LABEL) command to
suppress the printing of labels.

    The text may contain tt(\n) characters (two characters) which are
transformed to a newline character.
    it() bf(LABEL)

    As noted, this clears a previously defined tt(LABEL) command.
    )

    Examples:
        verb(
    LABEL Inspecting files in /etc\nIncluding subdirectories
    LABEL
        )
    The second bf(LABEL) command clears the first label.
    
subsect(LOCAL commands)

    bf(LOCAL) commands can be used to specify commands that are 
executed on the controller itself. The following bf(LOCAL) commands are
available: 
    itemization(
    it() bf(LOCAL) tt(command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The command must succeed (i.e., must return a zero exit value). 
    Example:
        verb(
    LOCAL mkdir /tmp/client
        )
    This command will create the directory tt(/tmp/client) on the controller.

    it() bf(LOCAL NOTEST) tt(command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The command may or may not succeed.
    Example:
        verb(
    LOCAL NOTEST mkdir /tmp/subdir
        )
    This command will create tt(/tmp/subdir) on the controller. The command
will fail if the directory cannot be created, but this will not terminate
bf(stealth).

    it() bf(LOCAL CHECK) [bf(LOG =)] tt(logfile [pathOffset] command)

    Execute tt(command) on the controller, using the bf(SH) command shell. 
The phrase `bf(LOG =)' is optional. 

The tt([pathOffset]) is also optional. If specified it defines the (0-based)
offset where path-names of inspected files start in lines produced by the
diff-command, comparing the previous report and the output generated by
tt(<command>). By default bf(stealth) assumes that the first occurrence of a
forward slash defines the first character of the path-names of inspected
files.

    For example, if diff-output looks like this:
        verb(
    01234567890123456789012345678901234567890 (column offsets, not part of 
                                               the diff-output)

    33c33
    < 90d8b506d249634c4ff80b9018644567  filename-specification
    ---
    > b88d0b77db74cc4a742d7bc26cdd2a1e  filename-specification
        )
    then the specification
        verb(
    LOCAL CHECK logfile 36 command-to-be-executed
        )
    informs bf(stealth) where to find the filename specifications in the
diff-output. Using the standard tt(/usr/bin/diff) command, this offset equals
2 + the offset of the tt(filename-specification) found in
tt(command-to-be-executed). 

If the command does not succeed a em(warning) message is written to the report
file. The warning message informs the reader that `remaining results might be
forged:
        verb(
    *** BE CAREFUL *** REMAINING RESULTS MAY BE FORGED
        )
    This situation may occur, e.g., if an essential program (like tt(sha1sum))
was transferred to the controller, and it was apparently modified since the
previous check. Processing continues, but remaining checks performed at the
client computer should be interpreted with em(extreme) caution.

    The output of this command is compared to the output of this command
generated during the previous run of bf(stealth). Any differences are written
to bf(REPORT). 

    If differences were found, the existing tt(logfile) name is renamed to
tt(logfile.YYYYMMDD-HHMMSS), with tt(YYYYMMDD-HHMMSS) the datetime-stamp at
the time bf(stealth) was run.

    Over time, many tt(logfile.YYMMDD-HHMMSS) files could be accumulated.
It is up to the controller's systems manager to decide what to do
with old datetime-stamped logfiles. For instance, the following script
will remove  all bf(stealth) reports below the current directory that are
older than 30 days:
        verb(
    #/bin/sh
    FILES=`find ./ -path '*[0-9]' -mtime +30 -type f`

    if [ "$FILES" != "" ] ; then
        rm -f $FILES
    fi
        )

    The tt(logfile) specifications may use relative and absolute paths. When
relative paths are used, these paths are relative to bf(BASE). When the
directories implied by the tt(logfile) specifications do not yet exist, they
are created first.

    Example:
        verb(
    LOCAL CHECK LOG = local/sha1sum sha1sum /tmp/sha1sum
        )
    This command will check the SHA1 sum of the tt(/tmp/sha1sum) program. The
resulting output is saved at bf(BASE)tt(/local/sha1sum). The program must
succeed (i.e., tt(sha1sum) must return a zero exit-value).

    it() bf(LOCAL NOTEST CHECK)  [bf(LOG =)] tt(logfile [pathOffset] command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The phrase `bf(LOG =)' is optional.  The command may or may not
succeed. Otherwise, the program performs exactly like the bf(LOCAL CHECK ...)
command, discussed above.

    Example:
        verb(
    LOCAL NOTEST CHECK LOG=local/sha1sum sha1sum /tmp/sha1sum
        )
    This command will check the SHA1 sum of the tt(/tmp/sha1sum) program. The
resulting output is saved at bf(BASE)tt(/local/sha1sum). The program may or may
not succeed (i.e., tt(sha1sum) may or may not return a zero exit-value).
    )

subsect(REMOTE commands)

    Plain commands can be executed on the client computer by merely
specifying them. Of course, this means that programs called
tt(LABEL), tt(LOCAL) tt(USE) or tt(DEFINE), cannot be executed, since
these names are interpreted otherwise by bf(stealth). It's unlikely that this
will cause problems. Remote commands must succeed (i.e., their return 
codes must be 0).

    Remote commands are commands executed on the client using the bf(SSH)
shell. These commands are executed using the standard tt(PATH) set for the
bf(SSH) shell. However, it is advised to specify the full pathname to the
programs to be executed, to prevent ``trojan approaches'' where a trojan horse
is installed in an `earlier' directory of the tt(PATH)-specification than the
intended program.

    Two special remote commands are tt(GET) and tt(PUT), which can be used to
copy files between the client and the controller.  Internally, tt(GET) and
tt(PUT) use the tt(DD) use-specification. If a non-default specification is
used, one should ensure that the alternate program accepts bf(dd)(1)'s tt(if=,
of=, bs=) and tt(count=) options. With tt(GET) the options tt(bs=, count=) and
tt(of=) are used, with tt(PUT) the options tt(bs=, count=) and tt(if=) are
used. Normally there should be no need to alter the default tt(DD)
specification.

    The tt(GET) command may be used as follows:
    startit()    
    it() bf(GET) tt(<client-path> <local-path>)nl()
    Copy the file indicated by tt(client-path) at the client to tt(local-path)
at the controller. tt(client-path) must be the full path of an existing file
on the client, tt(local-path) may either be a local directory, in which case
the client's file name is used, or another file name may be specified, in
which case the client's file is copied to the specified local filename. If the
local file already exists, it is overwritten by the copy-procedure.

    Example:nl()
    tt(GET /usr/bin/sha1sum /tmp)nl()
    The program tt(/usr/bin/sha1sum), available at the client, is copied to the
controller's tt(/tmp) directory. If the copying fails for some reason,
any subsequent commands are skipped, and bf(stealth) terminates.

    it() bf(GET NOTEST) tt(<client-path> <local-path>)nl()
    Copy the file indicated by tt(client-path) at the client to tt(local-path)
at the controller. tt(client-path) must be the full path of an existing file
on the client, tt(local-path) may either be a local directory, in which case
the client's file name is used, or another file name may be specified, in
which case the client's file is copied to the specified local filename. If the
local file already exists, it is overwritten by the copy-procedure.

    Example:nl()
    tt(GET NOTEST /usr/bin/sha1sum /tmp)nl()
    The program tt(/usr/bin/sha1sum), available at the client, is copied to the
controller's tt(/tmp) directory. Remaining commands in the policy file are
executed, even if the copying process wasn't successful.
    endit()

    The tt(PUT) command may be used as follows:
    startit()    
    it() bf(PUT) tt(<local-path> <remote-path>)nl()
    Copy the file indicated by tt(local-path) at the controller to
tt(remote-path) at the client. The argument tt(local-path) must be the
full path of an existing file on the controller. The argument tt(remote-path)
must be the full path to a file on the client. If the remote file already
exists, it is overwritten by tt(PUT).

    Example:nl()
    tt(PUT /tmp/sha1sum /usr/bin/sha1sum)nl()
    The program tt(/tmp/sha1sum), available at the controller, is copied to the
client as tt(usr/bin/sha1sum). If the copying fails for some reason,
any subsequent commands are skipped, and bf(stealth) terminates.

    it() bf(PUT NOTEST) tt(<local-path> <remote-path>)nl()
    Copy the file indicated by tt(local-path) at the controller to
tt(remote-path) at the client. The argument tt(local-path) must be the
full path of an existing file on the controller. The argument tt(remote-path)
must be the full path to a file on the client. If the remote file already
exists, it is overwritten by tt(PUT).

    Example:nl()
    tt(PUT NOTEST /tmp/sha1sum /usr/bin/sha1sum)nl()
    Copy the file indicated by tt(local-path) at the controller to
tt(remote-path) at the client. The argument tt(local-path) must be the full
path of an existing file on the controller. The argument tt(remote-path) must
be the full path to a file on the client. If the remote file already exists,
it is overwritten by tt(PUT). Remaining commands in the policy file are
executed, even if the copying process wasn't successful.
    endit()

    Other commands to be executed on the client can be specified as follows:

    itemization(
    it() tt(command)

        Execute `tt(command)' on the client, using the bf(SSH) command
shell. The command must succeed (i.e., must return a zero exit
value). However, any output generated by the command is ignored. 
    Example:
        verb(
    /usr/bin/find /tmp -type f -exec /bin/rm {} \;
        )
    This command will remove all ordinary files at and below the client's
tt(/tmp) directory.

    it() bf(NOTEST) tt(command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The command may or may not succeed.

    Example:
        verb(
    NOTEST /usr/bin/find /tmp -type f -exec /bin/rm {} \;
        )
    Same as the previous command, but this time the exit value of
tt(/usr/bin/find) is not interpreted.

    it() bf(CHECK)  [bf(LOG =)] tt(logfile [pathOffset] command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The phrase `bf(LOG =)' is optional. The tt([pathOffset]) specification
is also optional, and has the same meaning as for the tt(LOCAL CHECK) command,
described above. 

The command must succeed. The output of this command is compared to the
output of this command generated during the previous run of bf(stealth). Any
differences are written to bf(REPORT). If differences were found, the existing
tt(logfile) name is renamed to tt(logfile.YYYYMMDD-HHMMSS), with
tt(YYYYMMDD-HHMMSS) the datetime-stamp at the time bf(stealth) was run.

    Note that the command is executed on the client, but the logfile is kept
on the controller. This command represents the core of the method implemented
by bf(stealth): there will be no residues of the actions performed by
bf(stealth) on the client computers.

    Several examples (note the use of the backslash as line continuation
characters):
    COMMENT(CAREFUL: EXTRA BLANK REQUIRD IN THE YODL FILE BEHIND \ )
        verb(
    CHECK LOG = remote/ls.root  /usr/bin/find / \ 
            -xdev -perm /6111 -type f -exec /bin/ls -l {} \;
        )
    All suid/gid/executable files on the same device as the root-directory (/)
on the client computer are listed with their permissions, owner and size
information. The resulting listing is written on the file
bf(BASE)tt(/remote/ls.root). 

    This long command could be formulated shorter using a tt(DEFINE):
        verb(
    DEFINE LSFIND   -xdev -perm /6111 -type f -exec /bin/ls -l {} \;
    CHECK remote/ls.root  /usr/bin/find / ${LSFIND}
        )

    Another example:
        verb(
    DEFINE SHA1SUM -xdev -perm /6111 -type f -exec /usr/bin/sha1sum {} \;
    CHECK remote/sha1.root /usr/bin/find / ${SHA1SUM}
        )
    The SHA1 checksums of all suid/gid/executable files on the same device as
the root-directory (/) on the client computer are determined.  The resulting
listing is written on the file bf(BASE)tt(/remote/sha1.root).

    it() bf(NOTEST CHECK)  [bf(LOG =)] tt(logfile [pathOffset] command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The phrase `bf(LOG =)' is optional. The tt([pathOffset]) is also
optional, and has the same meaning as for the tt(LOCAL CHECK) command,
described above. The command may or may not succeed. Otherwise, the program
acts identically as the bf(CHECK ...) command, described above.
    Example (using the same tt(${SHA1SUM}))definition:
        verb(
    NOTEST CHECK LOG = remote/sha1.root /usr/bin/find / ${SHA1SUM}
        )
    The SHA1 checksums of all suid/gid/executable files on the same device as
the root-directory (/) on the client computer are determined.  The resulting
listing is written on the file bf(BASE)tt(/remote/sha1.root). bf(stealth) will
not terminate if the tt(/usr/bin/find) program returns a non-zero exit value.
    )

subsect(Preventing Controller Denial of Service (--max-size))

Either by malicious intent or by accendent (as happened to me) the controller
may be a victim of a Denial of Service (DOS) attack. This DOS attack may
happen when the client (apparently) sends a never ending stream of bytes in
response to a tt(GET) or tt(REMOTE) command. One of my controllers once fell
victim to this attack when a client's power went down and the controller kept 
on trying to read bytes from that client filling up the controllers disk....

This problem was of course caused by a programming error: while reading
information from a client bf(stealth) failed to check whether the reading
had actually succeeded. This bug has now been fixed, but an intentional
DOS attack could still be staged along this line by a hacker who manages to
replace, e.g., the bf(find)(1) command by a manipulated version which would
continue to write information to its standard output stream. Without further
precaution bf(stealth) would receive a never ending stream of bytes as its
`report' thus causing its disk to fill. 

To prevent this from happening bf(stealth) now offers the tt(--max-size)
command line option allowing the specification of the maximum size of a stream
of bytes received by bf(stealth) (e.g., a report or downloaded file). The
maximum is used for each individual download and can be specified in bytes
(using no suffix or the tt(B) suffix), kilo-bytes (using tt(K)), mega-bytes
(using tt(M)) or giga-bytes (using tt(G)). The default is set at 10M,
equivalent to the command line specification of tt(--max-size 10M). 

If a file or report received from the client exceeds its maximum allowed size
then bf(stealth) terminates after writing the following message to the report
file (which is sent to the configured mail address):
        verb(
    STEALTH - CAN'T CONTINUE: `<name of offending file>' EXCEEDS MAX. 
                                                DOWNLOAD SIZE (<size shown>)
    STEALTH - THIS COULD SIGNAL A SERIOUS PROBLEM WITH THE CLIENT
    STEALTH - ONE OR MORE LOG FILES MAY BE INVALID AS A RESULT
    STEALTH - *** INVESTIGATE ***
        )
    Since a tt(--max-size) specification may cause bf(stealth) to terminate
while receiving the output of a (remotely run) command, an empty or partial
log file will be the result. Of course this partial result is spurious as it
is a direct result of bf(stealth) terminating due to a size violation. 

    After investigating (and removing) the reasons for the size violation a
new bf(stealth) run using the previous log file as the latest baseline should
show only expected changes.

    For example, assume the following situation represents a (valid) state of
logfiles:
        verb(
    etc                       stealth                   
    setuid                    stealth.20080316-105756   
        )
    Now bf(stealth) is run with tt(--max-size 20), prematurely 
terminating bf(stealth). This results in the following set of logfiles:
        verb(
    etc                       stealth
    setuid                    stealth.20080316-105756   
                              stealth.20080316-110215 
        )
    The file tt(stealth) now contains incomplete data with the (latest) file
tt(stealth.20080316-110215) containing its previous contents.

    Now the reasons for the size-violation should be investigated and
removed. It is suggested to move the file last saved
(tt(stealth.20080316-110215)) to the file tt(stealth), as it represents the
state before the size violation was encountered. Following this bf(stealth)
should operate normally again.
