Access is granted via the tt(ssh) protocol.

The client must allow the controller to connect using tt(ssh). S() connects to
its clients using ssh certificates, after transferring the controler's public
key to its clients.

subsect(The controller's user: creating an ssh-key)

    The user on the controller calling s() to scan the client,
first generates an tt(ssh-keypair):
        verb(    ssh-keygen -t rsh) 
    This generates a public/private ssh key pair in tt(.ssh) in the
user's home directory. The program asks for a em(passphrase). A passphrase can
be defined (in which case it must be proviced when s() is started) or, if the
security if the controller is sufficiently guaranteed, it can be
empty. Pressing tt(Enter) in response to the question
        verb(    Enter passphrase (empty for no passphrase):)
    does the trick (a confirmation is required: simply press tt(Enter) again).

    tt(Ssh-keygen) then  returns a key fingerprint, e.g.,
        verb(    03:96:49:63:8a:64:33:45:79:ab:ca:de:c8:c8:4f:e9 user@controller)
    which may be saved for future reference.

    In the user's tt(.ssh) directory the files tt(id_rsa) and tt(id_rsa.pub)
are now created, which completes the actions on the controller.

subsect(The client's account: accepting ssh from the controller's user)

    Next, the account on the client where the tt(ssh) command connects to
(using a specification in the policy file like 
        verb(    USE SSH /usr/bin/ssh -q account@client)
must now grant access to the controller's user. In order to do so, the file
tt(id_rsa.pub) of the user at the controller is added to the file
tt(authorized_keys) in the tt(.ssh) directory of the account on the client:
        verb(    # transfer user@controller's file id_rsa.pub to the client's /tmp
    # directory. Then do:

    cat /tmp/id_rsa.pub >> /home/account/.ssh/authorized_keys)

    Now user@controller may login at acount@client without specifying a
client password. Of course, if the ssh-key was passphrase protected this
passphrase must be provided at the controller once s() is started.

subsect(Logging into the account@client account)

    When user@controller now issues, for the first time, the command
        verb(    ssh account@controller)
    tt(Ssh) responds like this:
        verb(    The authenticity of host 'controller (xxx.yyy.aaa.bbb)' can't be
    established.
    RSA key fingerprint is c4:52:d6:a3:d4:65:0d:5e:2e:66:d8:ab:de:ad:12:be.
    Are you sure you want to continue connecting (yes/no)?)
    Answering tt(yes) results in the message:
        verb(    Warning: Permanently added 'controller,xxx.yyy.aaa.bbb' (RSA) to the
    list of known hosts.)

    The next time a login is attempted, the authenticity question isn't asked
anyore. However, the proper value of the host's RSA key fingerprint (i.e., the
key fingerprint of the em(client) computer) should
em(always) be verified to prevent em(man in the middle) attacks. The proper
value may be obtained at the client computer by issuing the command
        verb(    ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key.pub)
    This should result in the same value as the fingerprint shown when the
first tt(ssh) connection was made. E.g.,
        verb(    1024 c4:52:d6:a3:d4:65:0d:5e:2e:66:d8:ab:de:ad:12:be ssh_host_rsa_key.pub)

subsect(Using the proper shell)

    On order to minimize the amount of clutter and possible complications when
only a simple command-shell is required for executing commands, it is
suggested to use a tt(bash) or tt(sh) shell when logging into the
tt(account@client)'s account.

    When another shell is already used for tt(account@client), then an extra
account (optionally using the same tt(UID) as the original account, but
using bf(sh)(1) as the shell), could be used. 

    In the bf(passwd)(5) file this could be realized for em(root) as
em(rootsh) as follows:nl()
        verb(    rootsh:x:0:0:root:/root:/bin/sh)
    If shadow passwording is used, an appropriate entry in the tt(/etc/shadow)
file is required as well.
