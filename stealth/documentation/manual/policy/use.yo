sect(USE directives)

    tt(USE) directives provide bf(stealth) with arguments which
may be conditional to a certain installation. The following bf(USE) directives
may be specified:
    itemization(
    it() bf(USE BASE) tt(basedirectory)

        bf(BASE) defines the directory from where bf(stealth) operates. All
relative path specifications are interpreted relative to bf(BASE). em(By
default) this is the directory where bf(stealth) was started. 

    bf(BASE) and all other directories that are used below tt(BASE)
are created by bf(stealth) if not yet existing.

    Example:
        verb(
    USE BASE /root/client
        )
    All information generated by bf(stealth) is written in or below the
directory tt(/root/client). 

    it() bf(USE DD) tt(<dd>)nl()
        The bf(DD) specification uses tt(/bin/dd) as default, and defines the
location of the bf(dd)(1) program, both on the server and on the client. The
bf(bin)(1) program is used to copy files between the client and the controller
without opening separate ssh-connections. The program specified here is only
used by stealth for the tt(PUT) and tt(GET) commands, described below.

    Example showing the default:
        verb(
    USE DD /bin/dd
        )

    it() bf(USE DIFF) tt(path-to-diff)

        The bf(DIFF) specification uses tt(/usr/bin/diff) as default,
and defines the location of the bf(diff)(1) program. The
bf(diff)(1) program is used to compare a formerly created logfile of an
integrity check to a newly created logfile.

    Example showing the default:
        verb(
    USE DIFF /usr/bin/diff
        )
    
    it() bf(USE DIFFPREFIX) tt(<prefix>)nl()
        The bf(DIFFPREFIX) specification defines the size of the prefix added
by the tt(DIFF) command to lines produced by commands executed through s().
The default tt(/usr/bin/diff) program prefixes lines by either `tt(> )' or
`tt(< )'. The default value for tt(<prefix>) is therefore equal to 2.nl()
    Example showing the default:nl()
    tt(USE DIFFPREFIX 2)

    it() bf(USE EMAIL) tt(address)

        The bf(EMAIL) specification defines the email-address to e-mail the
client's integrity scan report to. Mail is only sent when information has
changed.

    Example showing the default:
        verb(
    USE EMAIL root
        )

    it() bf(USE MAILER) tt(mailer)

        The bf(MAILER) specification defines the program that is used to send
the mail to the bf(EMAIL)-address. By default this is bf(/usr/bin/mail)(1). 
The bf(MAILER) program is called as follows:
        verb(
    MAILER  MAILARGS EMAIL
        )
    (tt(MAILARGS): see below). The information to be mailed is read from
tt(MAILER)'s standard input stream.

    Example showing the default:
        verb(
    USE MAILER /usr/bin/mail
        )

    it() bf(USE MAILARGS) tt(arguments)
        The bf(MAILARGS) specification defines the arguments to be
to be passed to the tt(MAILER) program. By default this is 
        verb(
    USE MAILARGS -s "STEALTH scan report"
        ) 
    Note that blanks may be used in the subject specification: use double or
single quotes to define elements containing blanks. Use tt(\") to use a double
quote in a string that is itself delimited by double quotes, use tt(\') to use
a single quote in a string that is itself delimited by single quotes. 

    Subtle note: in a construction like 
        verb(
    USE MAILARGS " 't was brillig " and 't went well
        )
    the following arguments are passed to tt(MAILER):
        itemization(
        it() tt(" 't was brillig ")
        it() tt(and)
        it() tt('t)
        it() tt(went)
        it() tt(well)
        )
    So, when single- and double-quoted strings overlap, the first string is
taken as a string, and the information beyond the first string is thereupon
interpreted. 

    it() bf(USE REPORT) tt(reportfile)

        bf(REPORT) defines the name of the reportfile. Information is always
appended to this file. For each run of bf(stealth) a em(time marker line) is
written to the report file. Such a marker line looks like this:
        verb(
    STEALTH (1.11) started at Mon Jun 16 12:57:26 2003
        )
    Only when (in addition to the marker line)
additional information was appended to the report file, the added contents of
the report file are mailed to the mail address specified in the bf(USE EMAIL)
specification.

    Example showing the default:
        verb(
    USE REPORT report
        )

    it() bf(USE ROTATE) tt(interval: number interval-name)[,] 
                        [tt(count: number)][,]
                        [tt(, zip: number [zip-program-path])]

        bf(ROTATE) defines the parameters  bf(stealth) will use to rotate its
report file. This bf(USE) specification supports three elements, the first of
which is obligatory when bf(USE ROTATE) is specified. Note that the square
brackets are not used in the specification, and indicate optional elements,
which may or may not be specified:
        itemization(
        it() tt(interval: number interval-name) defines the time interval
until the report file is rotated. Rotation can be specified using an integral,
positive number, followed by tt(hour) or tt(hours) for hours, tt(day) or
tt(days) for days, tt(week) or tt(weeks) for weeks and tt(month) or tt(months)
for months. By default no rotation takes place. If rotation is requested, the
current report file is moved to the file tt(reportfile)bf(.1), while existing
numbered reportfiles are moved to higher ordered numbers first (so, before
moving the current reportfile to tt(reportfile)bf(.1), an existing
tt(reportfile)bf(.1) is first moved to tt(reportfile)bf(.2), etc.).
        it() tt(count: number) defines the number of report files bf(stealth)
will eventually use. By default, if bf(USE ROTATE) is specified, there is no
practical limit to the number of report files bf(stealth) will create (in
these cases, another program supposedly controls the number of report files
that will eventually be used). External programs may freely manipulate all
report files that have been rotated by bf(stealth), but they should not modify
the active report file (specified using the bf(USE REPORT) specification).
        it() tt(zip: number zip-program-path) defines the first of the rotated
files that should be compressed, using tt(zip-program-path) to compress the
report files. By default, no compression is used, but if tt(zip:) is
specified, the default program that will be used to compress a report file is
bf(/bin/gzip). If another program is used, it should expect a filename as its
first argument, which will then be zipped to a new file receiving the
extension bf(.gz), appended to the name that was provided as its first
argument. The original file is removed during the zipping-process.

    Example showing a report interval of one week, using a total of 12 report
files, compressing all report files but the actual  report file and its
predecessor (having filename tt(reportfile)bf(.1)):
        verb(
    USE ROTATE interval: 1 week, count: 12, zip: 2 /bin/gzip
        )
    )
    it() bf(USE SH) tt(sh-specification)

        The bf(SH) specification uses tt(/bin/sh) as default, and defines the
command shell used by the controller to execute local commands.

    Example showing the default:

        verb(
    USE SH /bin/sh
        )

    it() bf(USE SSH) tt(ssh-specification)

        bf(The SSH specification has no default), and em(must) be
specified. Assuming the client em(trusts) the controller (which is, after all,
what this program is all about; so this should not be a very strong
assumption), preferably the public ssh-identity key of the controller should
be placed in the client's root tt(.ssh/authorized_keys) file, granting the
controller root access to the client. Root access is normally needed to gain
access to all directories and files of the client's file system.

    In practice, connecting to a account using the bf(sh)(1) shell is
preferred. When another shell is already used by that account, one should make
sure that that shell doesn't setup its own redirections for standard input and
standard output. One way to accomplish that is for force the execution of
tt(/bin/sh) in the bf(USE SSH) specification. 

    An example of an tt(SSH) specification to scan a localhost is:
        verb(
    USE SSH root@localhost -T -q                # root's shell is /bin/sh
        )

    The same, now explicitly using tt(/bin/bash):
        verb(
    USE SSH root@localhost -T -q exec /bin/bash # root uses another shell
        )

    Alternatively, tt(--profile) can be specified to prevent any
profile-initialization: 
        verb(
    USE SSH root@localhost -T -q exec /bin/bash --noprofile 
        )    
    )
    Note, however, that using tt(stealth) to inspect tt(localhost) is em(not)
recommended, as it counters one of the main reasons for tt(stealth)'s
existence. 

    As yet another alternative, applicable only to tt(localhost), tt(ssh)
could be avoided altogether. In that case tt(/bin/bash) or a comparable shell
may be specified with tt(USE SSH). For example:
        verb(
    # For stealth inspecting localhost:
        USE SSH /bin/bash --noprofile
        )



