lsect(COMMANDS)(Commands)

    Following the bf(USE) specifications, em(commands) can be specified. The
commands are executed in their order of appearance in the policy
file. Processing continues until the last command has been processed or until
a tested command (see below) returns a non-zero return value.

subsect(LABEL commands)
    
    The following bf(LABEL) commands are available:
    itemization(
    it() bf(LABEL) tt(text)

        This defines a text-label which is written to the bf(REPORT) file,
just before the output generated by the next bf(CHECK)-command. If the next
bf(CHECK)-command generates no output, the label is not written to the
bf(REPORT)-file. Once a bf(LABEL) has been defined, it is used until it is
redefined by the next bf(LABEL) command. Use an empty bf(LABEL) command to
suppress the printing of labels.

    The text may contain tt(\n) characters (two characters) which are
transformed to a newline character.
    it() bf(LABEL)

    As noted, this clears a previously defined tt(LABEL) command.
    )

    Examples:
        verb(
    LABEL Inspecting files in /etc\nIncluding subdirectories
    LABEL
        )
    The second bf(LABEL) command clears the first label.
    
subsect(LOCAL commands)

    bf(LOCAL) commands can be used to specify commands that are 
executed on the controller itself. The following bf(LOCAL) commands are
available: 
    itemization(
    it() bf(LOCAL) tt(command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The command must succeed (i.e., must return a zero exit value). 
    Example:
        verb(
    LOCAL scp rootsh@client:/usr/bin/md5sum /tmp
        )
    This command will copy the client's bf(md5sum)(1) program to the
controller.

    it() bf(LOCAL NOTEST) tt(command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The command may or may not succeed.
    Example:
        verb(
    LOCAL NOTEST mkdir /tmp/subdir
        )
    This command will create tt(/tmp/subdir) on the controller. The command
will fail if the directory cannot be created, but this will not terminate
tt(stealth).

    it() bf(LOCAL CHECK) [bf(LOG =)] tt(logfile command)

    Execute tt(command) on the controller, using the bf(SH) command shell. 
The phrase `bf(LOG =)' is optional. 
If
the command does not succeed a em(warning) message is written to the report
file. The warning message informs the reader that `remaining results might be
forged:
        verb(
    *** BE CAREFUL *** REMAINING RESULTS MAY BE FORGED
        )
    This situation may occur, e.g., if an essential program (like tt(md5sum))
was transferred to the controller, and it was apparently modified since the
previous check. Processing continues, but remaining checks performed at the
client computer should be interpreted with em(extreme) caution.

    The output of this command is compared to the output of this command
generated during the previous run of tt(stealth). Any differences are written
to bf(REPORT). 

    If differences were found, the existing tt(logfile) name is renamed to
tt(logfile.YYYYMMDD-HHMMSS), with tt(YYYYMMDD-HHMMSS) the datetime-stamp at
the time tt(stealth) was run.

    Over time, many tt(logfile.YYMMDD-HHMMSS) files could be accumulated.
It is up to the controller's systems manager to decide what to do
with old datetime-stamped logfiles. For instance, the following script
will remove  all tt(stealth) reports below the current directory that are
older than 30 days:
        verb(
    #/bin/sh
    FILES=`find ./ -path '*[0-9]' -mtime +30 -type f`

    if [ "$FILES" != "" ] ; then
        rm -f $FILES
    fi
        )

    The tt(logfile) specifications may use relative and absolute paths. When
relative paths are used, these paths are relative to bf(BASE). When the
directories implied by the tt(logfile) specifications do not yet exist, they
are created first.

    Example:
        verb(
    LOCAL CHECK LOG = local/md5sum md5sum /tmp/md5sum
        )
    This command will check the MD5 sum of the tt(/tmp/md5sum) program. The
resulting output is saved at bf(BASE)tt(/local/md5sum). The program must
succeed (i.e., tt(md5sum) must return a zero exit-value).

    it() bf(LOCAL NOTEST CHECK)  [bf(LOG =)] tt(logfile command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The phrase `bf(LOG =)' is optional. 
The command may or may not succeed. Otherwise, the program acts
identically as the bf(LOCAL CHECK ...) command, discussed previously.

    Example:
        verb(
    LOCAL NOTEST CHECK LOG=local/md5sum md5sum /tmp/md5sum
        )
    This command will check the MD5 sum of the tt(/tmp/md5sum) program. The
resulting output is saved at bf(BASE)tt(/local/md5sum). The program may or may
not succeed (i.e., tt(md5sum) may or may not return a zero exit-value).
    )

subsect(REMOTE commands)

    Plain commands can be executed on the client computer by merely
specifying them. Of course, this means that programs called
tt(LABEL), tt(LOCAL) tt(USE) or tt(DEFINE), cannot be executed, since
these names are interpreted otherwise by tt(stealth). It's unlikely that this
will cause problems. Remote commands must succeed (i.e., their return 
codes must be 0).

    Remote commands are commands executed on the client using the bf(SSH)
shell. These commands are executed using the standard tt(PATH) set for the
bf(SSH) shell. However, it is advised to specify the full pathname to the
programs to be executed, to prevent ``trojan approaches'' where a trojan horse
is installed in an `earlier' directory of the tt(PATH)-specification than the
intended program.

    Commands to be executed on the client can be specified as follows:
    itemization(
    it() tt(command)

        Execute `tt(command)' on the client, using the bf(SSH) command
shell. The command must succeed (i.e., must return a zero exit
value). However, any output generated by the command is ignored. 
    Example:
        verb(
    /usr/bin/find /tmp -type f -exec /bin/rm {} \;
        )
    This command will remove all ordinary files at and below the client's
tt(/tmp) directory.

    it() bf(NOTEST) tt(command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The command may or may not succeed.

    Example:
        verb(
    NOTEST /usr/bin/find /tmp -type f -exec /bin/rm {} \;
        )
    Same as the previous command, but this time the exit value of
tt(/usr/bin/find) is not interpreted.

    it() bf(CHECK)  [bf(LOG =)] tt(logfile command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The phrase `bf(LOG =)' is optional. 
The command must succeed. The output of this command is compared to the
output of this command generated during the previous run of tt(stealth). Any
differences are written to bf(REPORT). If differences were found, the existing
tt(logfile) name is renamed to tt(logfile.YYYYMMDD-HHMMSS), with
tt(YYYYMMDD-HHMMSS) the datetime-stamp at the time tt(stealth) was run.

    Note that the command is executed on the client, but the logfile is kept
on the controller. This command represents the core of the method implemented
by tt(stealth): there will be no residues of the actions performed by
tt(stealth) on the client computers.

    Several examples (note the use of the backslash as line continuation
characters):
    COMMENT(CAREFUL: EXTRA BLANK REQUIRD IN THE YODL FILE BEHIND \ )
        verb(
    CHECK LOG = remote/ls.root  /usr/bin/find / \ 
            -xdev -perm +6111 -type f -exec /bin/ls -l {} \;
        )
    All suid/gid/executable files on the same device as the root-directory (/)
on the client computer are listed with their permissions, owner and size
information. The resulting listing is written on the file
bf(BASE)tt(/remote/ls.root). 

    This long command could be formulated shorter using a tt(DEFINE):
        verb(
    DEFINE LSFIND   -xdev -perm +6111 -type f -exec /bin/ls -l {} \;
    CHECK remote/ls.root  /usr/bin/find / ${LSFIND}
        )

    Another example:
        verb(
    DEFINE MD5SUM -xdev -perm +6111 -type f -exec /usr/bin/md5sum {} \;
    CHECK remote/md5.root /usr/bin/find / ${MD5SUM}
        )
    The MD5 checksums of all suid/gid/executable files on the same device as
the root-directory (/) on the client computer are determined.  The resulting
listing is written on the file bf(BASE)tt(/remote/md5.root).

    it() bf(NOTEST CHECK)  [bf(LOG =)] tt(logfile command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The phrase `bf(LOG =)' is optional. 
The command may or may not succeed. Otherwise, the program acts
identically as the bf(CHECK ...) command, discussed previously.
    Example (using the same tt(${MD5SUM}))definition:
        verb(
    NOTEST CHECK LOG = remote/md5.root /usr/bin/find / ${MD5SUM}
        )
    The MD5 checksums of all suid/gid/executable files on the same device as
the root-directory (/) on the client computer are determined.  The resulting
listing is written on the file bf(BASE)tt(/remote/md5.root). tt(stealth) will
not terminate if the tt(/usr/bin/find) program returns a non-zero exit value.
    )
