lsect(COMMANDS)(Commands)

    Following the bf(USE) specifications, em(commands) can be specified. The
commands are executed in their order of appearance in the policy
file. Processing continues until the last command has been processed or until
a tested command (see below) returns a non-zero return value.

subsect(LABEL commands)
    
    The following bf(LABEL) commands are available:
    itemization(
    it() bf(LABEL) tt(text)

        This defines a text-label which is written to the bf(REPORT) file,
just before the output generated by the next bf(CHECK)-command. If the next
bf(CHECK)-command generates no output, the label is not written to the
bf(REPORT)-file. Once a bf(LABEL) has been defined, it is used until it is
redefined by the next bf(LABEL) command. Use an empty bf(LABEL) command to
suppress the printing of labels.

    The text may contain tt(\n) characters (two characters) which are
transformed to a newline character.
    it() bf(LABEL)

    As noted, this clears a previously defined tt(LABEL) command.
    )

    Examples:
        verb(
    LABEL Inspecting files in /etc\nIncluding subdirectories
    LABEL
        )
    The second bf(LABEL) command clears the first label.
    
subsect(LOCAL commands)

    bf(LOCAL) commands can be used to specify commands that are 
executed on the controller itself. The following bf(LOCAL) commands are
available: 
    itemization(
    it() bf(LOCAL) tt(command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The command must succeed (i.e., must return a zero exit value). 
    Example:
        verb(
    LOCAL mkdir /tmp/client
        )
    This command will create the directory tt(/tmp/client) on the controller.

    it() bf(LOCAL NOTEST) tt(command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The command may or may not succeed.
    Example:
        verb(
    LOCAL NOTEST mkdir /tmp/subdir
        )
    This command will create tt(/tmp/subdir) on the controller. The command
will fail if the directory cannot be created, but this will not terminate
tt(stealth).

    it() bf(LOCAL CHECK) [bf(LOG =)] tt(logfile command)

    Execute tt(command) on the controller, using the bf(SH) command shell. 
The phrase `bf(LOG =)' is optional. 
If
the command does not succeed a em(warning) message is written to the report
file. The warning message informs the reader that `remaining results might be
forged:
        verb(
    *** BE CAREFUL *** REMAINING RESULTS MAY BE FORGED
        )
    This situation may occur, e.g., if an essential program (like tt(md5sum))
was transferred to the controller, and it was apparently modified since the
previous check. Processing continues, but remaining checks performed at the
client computer should be interpreted with em(extreme) caution.

    The output of this command is compared to the output of this command
generated during the previous run of tt(stealth). Any differences are written
to bf(REPORT). 

    If differences were found, the existing tt(logfile) name is renamed to
tt(logfile.YYYYMMDD-HHMMSS), with tt(YYYYMMDD-HHMMSS) the datetime-stamp at
the time tt(stealth) was run.

    Over time, many tt(logfile.YYMMDD-HHMMSS) files could be accumulated.
It is up to the controller's systems manager to decide what to do
with old datetime-stamped logfiles. For instance, the following script
will remove  all tt(stealth) reports below the current directory that are
older than 30 days:
        verb(
    #/bin/sh
    FILES=`find ./ -path '*[0-9]' -mtime +30 -type f`

    if [ "$FILES" != "" ] ; then
        rm -f $FILES
    fi
        )

    The tt(logfile) specifications may use relative and absolute paths. When
relative paths are used, these paths are relative to bf(BASE). When the
directories implied by the tt(logfile) specifications do not yet exist, they
are created first.

    Example:
        verb(
    LOCAL CHECK LOG = local/md5sum md5sum /tmp/md5sum
        )
    This command will check the MD5 sum of the tt(/tmp/md5sum) program. The
resulting output is saved at bf(BASE)tt(/local/md5sum). The program must
succeed (i.e., tt(md5sum) must return a zero exit-value).

    it() bf(LOCAL NOTEST CHECK)  [bf(LOG =)] tt(logfile command)

        Execute tt(command) on the controller, using the bf(SH) command
shell. The phrase `bf(LOG =)' is optional. 
The command may or may not succeed. Otherwise, the program acts
identically as the bf(LOCAL CHECK ...) command, discussed previously.

    Example:
        verb(
    LOCAL NOTEST CHECK LOG=local/md5sum md5sum /tmp/md5sum
        )
    This command will check the MD5 sum of the tt(/tmp/md5sum) program. The
resulting output is saved at bf(BASE)tt(/local/md5sum). The program may or may
not succeed (i.e., tt(md5sum) may or may not return a zero exit-value).
    )

subsect(REMOTE commands)

    Plain commands can be executed on the client computer by merely
specifying them. Of course, this means that programs called
tt(LABEL), tt(LOCAL) tt(USE) or tt(DEFINE), cannot be executed, since
these names are interpreted otherwise by tt(stealth). It's unlikely that this
will cause problems. Remote commands must succeed (i.e., their return 
codes must be 0).

    Remote commands are commands executed on the client using the bf(SSH)
shell. These commands are executed using the standard tt(PATH) set for the
bf(SSH) shell. However, it is advised to specify the full pathname to the
programs to be executed, to prevent ``trojan approaches'' where a trojan horse
is installed in an `earlier' directory of the tt(PATH)-specification than the
intended program.

    Two special remote commands are tt(GET) and tt(PUT), which can be used to
copy files between the client and the controller.  Internally, tt(GET) and
t(PUT) use the tt(DD) use-specification. If a non-default specification is
used, one should ensure that the alternate program accepts bf(dd)(1)'s tt(if=,
of=, bs=) and tt(count=) options. With tt(GET) the options tt(bs=, count=) and
tt(of=) are used, with tt(PUT) the options tt(bs=, count=) and tt(if=) are
used. Normally there should be no need to alter the default tt(DD)
specification.

    The tt(GET) command may be used as follows:
    startit()    
    it() bf(GET) tt(<client-path> <local-path>)nl()
    Copy the file indicated by tt(client-path) at the client to tt(local-path)
at the controller. tt(client-path) must be the full path of an existing file
on the client, tt(local-path) may either be a local directory, in which case
the client's file name is used, or another file name may be specified, in
which case the client's file is copied to the specified local filename. If the
local file already exists, it is overwritten by the copy-procedure.

    Example:nl()
    tt(GET /usr/bin/md5sum /tmp)nl()
    The program tt(/usr/bin/md5sum), available at the client, is copied to the
controller's tt(/tmp) directory. If the copying fails for some reason,
any subsequent commands are skipped, and bf(stealth) terminates.

    it() bf(GET NOTEST) tt(<client-path> <local-path>)nl()
    Copy the file indicated by tt(client-path) at the client to tt(local-path)
at the controller. tt(client-path) must be the full path of an existing file
on the client, tt(local-path) may either be a local directory, in which case
the client's file name is used, or another file name may be specified, in
which case the client's file is copied to the specified local filename. If the
local file already exists, it is overwritten by the copy-procedure.

    Example:nl()
    tt(GET NOTEST /usr/bin/md5sum /tmp)nl()
    The program tt(/usr/bin/md5sum), available at the client, is copied to the
controller's tt(/tmp) directory. Remaining commands in the policy file are
executed, even if the copying process wasn't successful.
    endit()

    The tt(PUT) command may be used as follows:
    startit()    
    it() bf(PUT) tt(<local-path> <remote-path>)nl()
    Copy the file indicated by tt(local-path) at the controller to
tt(remote-path) at the client. The argument tt(local-path) must be the
full path of an existing file on the controller. The argument tt(remote-path)
must be the full path to a file on the client. If the remote file already
exists, it is overwritten by tt(PUT).

    Example:nl()
    tt(PUT /tmp/md5sum /usr/bin/md5sum)nl()
    The program tt(/tmp/md5sum), available at the controller, is copied to the
client as tt(usr/bin/md5sum). If the copying fails for some reason,
any subsequent commands are skipped, and bf(stealth) terminates.

    it() bf(PUT NOTEST) tt(<local-path> <remote-path>)nl()
    Copy the file indicated by tt(local-path) at the controller to
tt(remote-path) at the client. The argument tt(local-path) must be the
full path of an existing file on the controller. The argument tt(remote-path)
must be the full path to a file on the client. If the remote file already
exists, it is overwritten by tt(PUT).

    Example:nl()
    tt(PUT NOTEST /tmp/md5sum /usr/bin/md5sum)nl()
    Copy the file indicated by tt(local-path) at the controller to
tt(remote-path) at the client. The argument tt(local-path) must be the full
path of an existing file on the controller. The argument tt(remote-path) must
be the full path to a file on the client. If the remote file already exists,
it is overwritten by tt(PUT). Remaining commands in the policy file are
executed, even if the copying process wasn't successful.
    endit()

    Other commands to be executed on the client can be specified as follows:

    itemization(
    it() tt(command)

        Execute `tt(command)' on the client, using the bf(SSH) command
shell. The command must succeed (i.e., must return a zero exit
value). However, any output generated by the command is ignored. 
    Example:
        verb(
    /usr/bin/find /tmp -type f -exec /bin/rm {} \;
        )
    This command will remove all ordinary files at and below the client's
tt(/tmp) directory.

    it() bf(NOTEST) tt(command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The command may or may not succeed.

    Example:
        verb(
    NOTEST /usr/bin/find /tmp -type f -exec /bin/rm {} \;
        )
    Same as the previous command, but this time the exit value of
tt(/usr/bin/find) is not interpreted.

    it() bf(CHECK)  [bf(LOG =)] tt(logfile command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The phrase `bf(LOG =)' is optional. 
The command must succeed. The output of this command is compared to the
output of this command generated during the previous run of tt(stealth). Any
differences are written to bf(REPORT). If differences were found, the existing
tt(logfile) name is renamed to tt(logfile.YYYYMMDD-HHMMSS), with
tt(YYYYMMDD-HHMMSS) the datetime-stamp at the time tt(stealth) was run.

    Note that the command is executed on the client, but the logfile is kept
on the controller. This command represents the core of the method implemented
by tt(stealth): there will be no residues of the actions performed by
tt(stealth) on the client computers.

    Several examples (note the use of the backslash as line continuation
characters):
    COMMENT(CAREFUL: EXTRA BLANK REQUIRD IN THE YODL FILE BEHIND \ )
        verb(
    CHECK LOG = remote/ls.root  /usr/bin/find / \ 
            -xdev -perm +6111 -type f -exec /bin/ls -l {} \;
        )
    All suid/gid/executable files on the same device as the root-directory (/)
on the client computer are listed with their permissions, owner and size
information. The resulting listing is written on the file
bf(BASE)tt(/remote/ls.root). 

    This long command could be formulated shorter using a tt(DEFINE):
        verb(
    DEFINE LSFIND   -xdev -perm +6111 -type f -exec /bin/ls -l {} \;
    CHECK remote/ls.root  /usr/bin/find / ${LSFIND}
        )

    Another example:
        verb(
    DEFINE MD5SUM -xdev -perm +6111 -type f -exec /usr/bin/md5sum {} \;
    CHECK remote/md5.root /usr/bin/find / ${MD5SUM}
        )
    The MD5 checksums of all suid/gid/executable files on the same device as
the root-directory (/) on the client computer are determined.  The resulting
listing is written on the file bf(BASE)tt(/remote/md5.root).

    it() bf(NOTEST CHECK)  [bf(LOG =)] tt(logfile command)

        Execute tt(command) on the client, using the bf(SSH) command
shell. The phrase `bf(LOG =)' is optional. 
The command may or may not succeed. Otherwise, the program acts
identically as the bf(CHECK ...) command, discussed previously.
    Example (using the same tt(${MD5SUM}))definition:
        verb(
    NOTEST CHECK LOG = remote/md5.root /usr/bin/find / ${MD5SUM}
        )
    The MD5 checksums of all suid/gid/executable files on the same device as
the root-directory (/) on the client computer are determined.  The resulting
listing is written on the file bf(BASE)tt(/remote/md5.root). tt(stealth) will
not terminate if the tt(/usr/bin/find) program returns a non-zero exit value.
    )

