#!/usr/bin/icmake -qt/tmp/stealth

// script generated by the C++ icmake script version 2.18

/*
Configurable defines:

    CLASSES:        string of directory-names under which sources of classes
                    are found. E.g., CLASSES  = "class1 class2"

    All class-names must be stored in one string.
    If classes are removed from the CLASSES definition or if the names in the
    CLASSES definition are reordered, the compilation should start again from
    scratch.
*/

string
    CLASSES;

void setClasses()
{
//  ADD ADDITIONAL DIRECTORIES CONTAINING SOURCES OF CLASSES HERE
//  Use the construction `CLASSES += "classname1 classname2";' etc.

    CLASSES +=  "util configsorter "
                " reporter"
                " scanner"
                " iofork"
                " monitor"
                ;
}

/*
    Default values for the following variables
    are found in $IM/default/defines.im

    BISON_FLAGS:    This directive is only used when a grammar is generated
                    using bison++. It defines the set of flags that are
                    given to bison++ when bison++ generates the parser.
                    By default the following flags are specified: -v -l
                    The -d and -o flags are always provided (not configurable)

    BUILD_LIBRARY:  define this if you want to create a library for the object
                    modules. Undefined by default: so NO LIBRARY IS
                    BUILT. This links ALL object files to a program, which is
                    a faster process than linking to a library. But it can
                    bloat the executable: all o-modules, rather than those
                    that are really used, become part of the program's code.

    BUILD_PROGRAM:  define if a program is to be built. If not defined,
                    library maintenance is assumed  (by default it is defined
                    to the name of the program to be created).

    COMPILER:       The compiler to use.
    COPT:           C-options used by COMPILER

    ECHO_REQUEST:   ON (default) if command echoing is wanted, otherwise: set
                    to OFF
    GDB:            define if gdb-symbolic debug information is wanted
                    (not defined by default)

    GRAMMAR_LINES:  When this directive is defined, #line directives will
                    be generated at the first C++ compound statement
                    in each individual grammar specification file. Undefine
                    if no such #line directives are required.

    LIBS:           Extra libraries used for linking
    LIBPATH:        Extra library-searchpaths used for linking

    QT:             Define this (default: to "qt") if the unthreaded QT
                    library is used. Define as "qt-mt" if the threaded QT
                    library is used.
                    If set, header files are grepped for the occurrence of
                    the string '^[[:space:]]*Q_OBJECT[[:space:]]*$'. If found,
                    moc -o moc<CLASSNAME>.cc <CLASSNAME>.h is called if
                    the moc-file doesn't exist or is older than the .h file.
                    Also, if defined the proper QT library is linked, assuming
                    that the library is found in the ld-search path
                    (E.g., see the environment variable $LIBRARY_PATH).

    Note that namespaces are NOT part of the build-script: they are only
    listed below for convenience. When they must be altered, the defaults must
    be changed in $IM/default/defines.im

    RELINK:         Defined by default, causing a program to be
                    relinked every time the script is called. Do not
                    define it if relinking should only occur if a
                    source is compiled. No effect for library maintenance.

    Current values:
*/
#define BUILD_LIBRARY
#define BUILD_PROGRAM      "sbin/stealth"

#define COMPILER           "g++"
#define COPT               "-Wall -O3"

#define ECHO_REQUEST       1
//#define GDB              "-g"

#define LIBS               "bobcat"
#define LIBPATH            ""

// local namespace is: FBB
// using-declarations generated for: std:FBB

#define GRAMBUILD
#define BISON_FLAGS        "-V -l"
#define GRAMMAR_LINES


//                      NO CONFIGURABLE PARTS BELOW THIS LINE

/*
                            V A R S . I M
*/

string                  // contain options for
    cwd,                // current WD
    libs,               // extra libs, e.g., "-lrss -licce"
    libpath,            // extra lib-paths, eg, "-L../rss"
    copt,               // Compiler options
    lopt,               // Linker options
    libxxx,             // full library-path
    ofiles,             // wildcards for o-files
    sources,            // sources to be used
    current,            // contains name of current dir.
    programname;        // the name of the program to create
int
    nClasses,           // number of classes/subdirectories
    program;            // 1: program is built
list
    envir,              // list of environment variables
    classes;            // list of classes/directories


string getenv(string target)
{
    int idx;
    string env;

    for (idx = 0; idx < sizeof(envir); ++idx)
    {
        env = element(idx, envir);
        if (env == target)
            return element(idx + 1, envir);
    }
    return "";
}

/*
                                I N I T I A L . I M
*/
void initialize()
{
    echo(ECHO_REQUEST);
    sources = "*.cc";
    ofiles = "o/*.o";                       // std set of o-files
    copt = COPT;

    #ifdef GDB
        copt += " " + GDB;
    #endif

    #ifdef BUILD_PROGRAM
        program = 1;
        programname = BUILD_PROGRAM;
    #else
        program = 0;
    #endif;

    cwd = chdir(".");

    setClasses();                           // remaining classes

    classes = strtok(CLASSES, " ");         // list of classes

    nClasses = sizeof(classes);
}


/*
                                M O C . I M
*/

void moc(string class)
{
    string hfile;
    string mocfile;
    int ret;

    hfile = class + ".h";
    mocfile = "moc" + class + ".cc";

    if
    (
        hfile younger mocfile       // no mocfile or younger h file
        &&                          // and Q_OBJECT found in .h file
        !system(P_NOCHECK,
                "grep '^[[:space:]]*Q_OBJECT[;[:space:]]*$' " + hfile)
    )                               // then call moc.
        system("moc -o " + mocfile + " " + hfile);
}
/*
                                O B J F I L E S . I M
*/

list objfiles(list files)
{
    string
        file,
        objfile;
    int
        i;

    for (i = 0; i < sizeof(files); i++)
    {
        file = element(i, files);           // determine element of the list
        objfile = "./o/" + change_ext(file, "o");    // make obj-filename
        if (objfile younger file)           // objfile is younger
        {
            files -= (list)file;            // remove the file from the list
            i--;                            // reduce i to test the next
        }
    }
    return (files);
}
/*
                                A L T E R E D . I M
*/

list altered(list files, string target)
{
    int
        i;
    string
        file;

    for (i = 0; i < sizeof(files); i++)     // try all elements of the list
    {
        file = element(i, files);           // use element i of the list

        if (file older target)              // a file is older than the target
        {
            files -= (list)file;            // remove the file from the list
            i--;                            // reduce i to inspect the next
        }                                   // file of the list
    }
    return (files);                         // return the new list
}
/*
                            F I L E L I S T . I M
*/

list file_list(string type, string library)
{
    list
        files;

    files = makelist(type);                 // make all files of certain type
    #ifdef BUILD_LIBRARY
        files = altered(files, library);    // keep all files newer than lib.
    #endif
    files = objfiles(files);                // remove if younger .obj exist

    return (files);
}
/*
                        L I N K . I M
*/

void link(string library)
{
    printf("\n");
    exec(COMPILER, "-o", programname,
        #ifdef BUILD_LIBRARY
            "-l" + library,
        #else
            ofiles,
        #endif
        libs,
        #ifdef QT
            "-l" + QT,
        #endif
        "-L.", libpath, lopt
        #ifndef GDB
            , "-s"
        #endif
    );
    printf("ok: ", programname, "\n");
}
/*
                          P R E F I X C L . I M
*/
void prefix_class(string class_id)
{
    list
        o_files;
    string
        o_file;
    int
        i;

    chdir("o");
    o_files = makelist("*.o");
    for (i = 0; o_file = element(i, o_files); i++)
        exec("mv", o_file, class_id + o_file);
    chdir("..");
}
/*
                          R M C L A S S P . I M
*/

#ifdef BUILD_LIBRARY
    string rm_class_id(string class_id, string ofile)
    {
        string
            ret;
        int
            index,
            n;

        n = strlen(ofile);
        for (index = strlen(class_id); index < n; index++)
            ret += element(index, ofile);

        return ret;
    }
#endif

void rm_class_prefix(string class_id)
{
    #ifdef BUILD_LIBRARY
        list
            o_files;
        string
            o_file;
        int
            i;

        chdir("o");
        o_files = makelist("*.o");
        for (i = 0; o_file = element(i, o_files); i++)
            exec("mv", o_file, rm_class_id(class_id, o_file));
        chdir("..");
    #endif
}
/*
                            C C O M P I L E . I M
*/

void c_compile(list cfiles)
{
        string
                nextfile;
        int
                i;

    if (!exists("o"))
        system("mkdir o");

    if (sizeof(cfiles))                 // files to compile ?
    {
        printf("\ncompiling: ", current, "\n\n");

                                        // compile all files separately
        for (i = 0; nextfile = element(i, cfiles); i++)
            exec(COMPILER,
                "-c -o o/" + change_ext(nextfile, "o"),
                copt, nextfile);

        printf("\n");
    }
    printf("ok: ", current, "\n");
}
/*
                            U P D A T E L I . I M
*/

void updatelib(string library)
{
    #ifdef BUILD_LIBRARY
        list
            arlist,
            objlist;
        string
            to,
            from;

        objlist = makelist("o/*.o");

        if (!sizeof(objlist))
            return;

        printf("\n");

        exec("ar", "rvs", library, "o/*.o");
        exec("rm", "o/*.o");

        printf("\n");
    #endif
}
/*
                                S T D C P P . I M
*/

void std_cpp(string library)
{
    list
        cfiles;

    cfiles = file_list(sources, library);     // make list of all cpp-files

    c_compile(cfiles);                      // compile cpp-files
}
/*
                                C P P M A K E . C

    CPP files are processed by stdmake.

    Arguments of CPPMAKE:

    cpp_make(
        string mainfile,    : name of the main .cpp file, or "" for library
                              maintenance
        string library,     : name of the local library to use/create
                                (without lib prefix or .a/.so suffix
                                (E.g., use `main' for `libmain.a')
        )

    Both mainfile and library MUST be in the current directory
*/

void cpp_make(string mainfile, string library)
{
    int
        index;
    string class;

    if (nClasses)
        ofiles += " */o/*.o";               // set ofiles for no LIBRARY use

                                            // make library name
    #ifdef BUILD_LIBRARY
        libxxx = chdir(".") + "lib" + library + ".a";
    #endif
                                            // first process all classes
    for (index = 0; index < nClasses; index++)
    {
        class = element(index, classes);  // next class to process
        chdir(class);                     // change to directory

        current = "subdir " + class;
        #ifdef QT
            moc(class);                     // see if we should call moc
        #endif
        std_cpp(libxxx);                    // compile all files
        chdir(cwd);                         // go back to parent dir
    }

    current = "auxiliary " + sources + " files";
    std_cpp(libxxx);                        // compile all files in current dir


    #ifdef BUILD_LIBRARY
                                        // prefix class-number for .o files
        for (index = 0; index < nClasses; index++)
        {
            current = element(index, classes);  // determine class name
            chdir( current);              // chdir to a class directory.
            prefix_class((string)index);
            updatelib(libxxx);
            chdir(cwd);                // go back to parent dir
        }
        current = "";                  // no class anymore
        updatelib(libxxx);             // update lib in current dir
    #endif

    if (mainfile != "")                // mainfile -> do link
    {
        link(library);
        printf
        (
            "\nProgram construction completed.\n"
            "\n"
        );
    }
}
/*
                        S E T L I B S . I M
*/
void setlibs()
{
    #ifdef LIBS
        int
            n,
            index;
        list
            cut;

        cut = strtok(LIBS, " ");        // cut op libraries
        n = sizeof(cut);
        for (index = 0; index < n; index++)
            libs += " -l" + element(index, cut);

        cut = strtok(LIBPATH, " ");     // cut up the paths
        n = sizeof(cut);
        for (index = 0; index < n; index++)
            libpath += " -L" + element(index, cut);
    #endif
}

void release()
{
    if ("VERSION" younger "release.yo")
        system("sh VERSION.sh");
}

void prog()
{
    release();
    system("mkdir -p sbin");

    initialize();
    setlibs();

    cpp_make
    (
        "stealth.cc", // program source
        "stealth"  // static program library
    );

//    system(P_NOCHECK, 
//            "sbin/stealth --help > usage");
}

void man()
{
    release();

    chdir("manpage");

    if 
    (
        "stealth.yo" younger "stealth.man"
        ||
        "../release.yo" younger "stealth.man"

    )
    {
        exec("yodl2man -o stealth.1 stealth");
        exec("yodl2html -o stealthman.html stealth");
    }

    chdir("..");
}

void manual()
{
    system("./buildmanual");
}

void debian()
{
    prog();
    man();
    manual();
}

void install(string where)
{
    string docbase;
    string docfiles;

    if (where == "")
    {
        printf("missing location to install as argument 2\n");
        exit(1);
    }

    printf("\ninstall stealth\n");
    system("mkdir -p " + where + "/usr/sbin");
    system("cp -p " + programname + " " + where + "/usr/sbin");

    printf("\ninstall manual page in .../man1\n");
    system("mkdir -p " +    where + "/usr/share/man/man1");
    system("gzip < manpage/stealth.1 > " + 
                            where + "/usr/share/man/man1/stealth.1.gz");

    printf("\ninstall remaining documentation under "
                                                "/usr/share/doc/stealth:\n");
    docbase = where + "/usr/share/doc/stealth/";
    system("mkdir -p " + docbase);

    docfiles = "ACKNOWLEDGEMENTS COPYING stealthmail example-policies";
    printf("\ninstall " + docfiles + "\n");
    exec("cp", "-prd", docfiles, docbase);

    printf("\ninstall man-page info\n");
    system("mkdir -p " +    docbase + "man");
    system("cp manpage/stealthman.html " + 
                            docbase + "man");

    printf("\ninstall manual info\n");
    system("mkdir -p " +    docbase + "manual");
    system("cp -prd manual " + 
                            docbase);
}

void cleanup()
{

    system("rm -rf build-stamp debian/stealth debian/stealth.substvars "
                   "configure-stamp ");

    if (getenv("STEALTH") == "minimal")
    {
        printf("\n"
                "WARNING: PERFORMED MINIMAL CLEANUP\n"
                "\n");
        return;
    }

    system("rm -rf release.{yo,h} sbin o */o libstealth.a ");
    system("rm -rf manpage/*.{1,html} manual/{LaTeX,html,pdf,ps,text}");
}

void main(int argc, list argv, list envp)
{
    string arg1;

    if (argc == 1)
    {
        printf
        (
            "\n"
            "Build what? Options are:\n"
            "   clean: clean up Define the STEALTH=minimal environment\n"
            "           variable to perform mimimal cleaning. Use with care!\n"
            "   debian: build stealth for the debian package (after `clean')\n"
            "           performs: build prog, build man\n"
            "   install WHERE: install the products under WHERE "
                                                "(following `build debian')\n"
            "                  The Debian installation process will install "
                                                        "under ./debian/\n"
            "   man:    build the stealth man-page (.1, .html versions)\n"
            "   manual: build the stealth manual\n"
            "   prog:   build the stealth program\n"
            "\n"
        );
        exit(1);
    }

    envir = envp;

    programname = BUILD_PROGRAM;
    arg1 = element(1, argv);

    if (arg1 == "clean")
        cleanup();
    else if (arg1 == "debian")
        debian();
    else if (arg1 == "install")
        install(element(2, argv));
    else if (arg1 == "man")
        man();
    else if (arg1 == "manual")
        manual();
    else if (arg1 == "prog")
        prog();
    else
    {
        printf("request `", arg1, "' not yet available\n");
        exit(1);
    }
    exit(0);
}
